// Generated by CoffeeScript 1.3.3
/* Collision Behaviour
*/

var Collision,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Collision = (function(_super) {

  __extends(Collision, _super);

  function Collision(useMass, callback) {
    this.useMass = useMass != null ? useMass : true;
    this.callback = callback != null ? callback : null;
    this.pool = [];
    this._delta = new Vector();
    Collision.__super__.constructor.apply(this, arguments);
  }
  Collision.prototype.add = function(p) {
    console.log('Added collision',this.pool,p)
    this.pool.push(p);
    p.behaviours.push(this);
  }
  Collision.prototype.remove = function(p) {
    this.pool.remove(p);
    p.behaviours.remove(this);
  }


  Collision.prototype.apply = function(p, dt, index) {
    var dist, distSq, i, mt, o, overlap, r1, r2, radii, _i, _ref, _results;
    _results = [];
    index = this.pool.indexOf(p)
    for (i = _i = index, _ref = this.pool.length - 1; index <= _ref ? _i <= _ref : _i >= _ref; i = index <= _ref ? ++_i : --_i) {
      o = this.pool[i];
      if (o===undefined) continue;
      if (o !== p) {
        (this._delta.copy(o.pos)).sub(p.pos);
        distSq = this._delta.magSq();
        radii = p.radius + o.radius;
        if (distSq <= radii * radii) {
          dist = Math.sqrt(distSq);
          overlap = (p.radius + o.radius) - dist;
          overlap += 0.5;
          mt = p.mass + o.mass;
          r1 = this.useMass ? o.mass / mt : 0.5;
          r2 = this.useMass ? p.mass / mt : 0.5;
          // if (!p.fixed && !o.fixed) {
            p.pos.add(this._delta.clone().norm().scale(overlap * -r1));
            o.pos.add(this._delta.norm().scale(overlap * r2));
          // }
          // else if(!p.fixed) {
          //   p.pos.add(this._delta.clone().norm().scale(overlap * (-r1-r2)));
          // }
          // else if(!o.fixed) {
          //   o.pos.add(this._delta.clone().norm().scale(overlap * (-r1-r2)));
          // }
          _results.push(typeof this.callback === "function" ? this.callback(p, o, overlap) : void 0);
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return Collision;

})(Behaviour);
